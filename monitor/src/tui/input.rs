//! Input handling for the VibeTea Monitor TUI.
//!
//! This module processes keyboard events and translates them into semantic actions
//! that the application can respond to. It handles context-sensitive input based on
//! the currently focused form field.
//!
//! # Architecture
//!
//! Input handling follows a two-stage pattern:
//!
//! 1. **Event Reception**: Raw [`KeyEvent`]s are received from crossterm
//! 2. **Action Translation**: Events are translated to [`SetupAction`]s based on context
//!
//! The translation is context-sensitive—the same key may produce different actions
//! depending on which form field is currently focused.
//!
//! # Example
//!
//! ```
//! use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
//! use vibetea_monitor::tui::app::SetupField;
//! use vibetea_monitor::tui::input::{SetupAction, handle_setup_key};
//!
//! // Typing 'a' in the session name field inserts the character
//! let key = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);
//! let action = handle_setup_key(key, SetupField::SessionName);
//! assert_eq!(action, SetupAction::InsertChar('a'));
//!
//! // Pressing Space on the key option field toggles the selection
//! let key = KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE);
//! let action = handle_setup_key(key, SetupField::KeyOption);
//! assert_eq!(action, SetupAction::ToggleOption);
//!
//! // Pressing Escape anywhere triggers quit
//! let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
//! let action = handle_setup_key(key, SetupField::Submit);
//! assert_eq!(action, SetupAction::Quit);
//! ```

use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

use crate::tui::app::SetupField;

/// Actions that can result from user input during the setup form.
///
/// This enum represents all possible user intentions that can be expressed
/// through keyboard input while the setup form is displayed. The main event
/// loop processes these actions to update application state accordingly.
///
/// # Action Categories
///
/// - **Text Input**: [`InsertChar`](SetupAction::InsertChar), [`DeleteChar`](SetupAction::DeleteChar)
/// - **Navigation**: [`NextField`](SetupAction::NextField), [`PreviousField`](SetupAction::PreviousField)
/// - **Selection**: [`ToggleOption`](SetupAction::ToggleOption)
/// - **Form Control**: [`Submit`](SetupAction::Submit), [`Quit`](SetupAction::Quit)
/// - **No-op**: [`None`](SetupAction::None)
///
/// # Example
///
/// ```
/// use vibetea_monitor::tui::input::SetupAction;
///
/// let action = SetupAction::InsertChar('x');
/// assert!(matches!(action, SetupAction::InsertChar('x')));
///
/// let action = SetupAction::NextField;
/// assert_eq!(action, SetupAction::NextField);
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SetupAction {
    /// Insert a character at the current cursor position.
    ///
    /// This action is only generated when the session name text field is focused
    /// and the user types a printable ASCII character. Non-ASCII characters are
    /// rejected and result in [`SetupAction::None`] instead.
    InsertChar(char),

    /// Delete the character before the cursor (Backspace).
    ///
    /// Generated when the user presses Backspace while the session name field
    /// is focused. If the field is empty, this action should be a no-op.
    DeleteChar,

    /// Move focus to the next field (Tab/Down arrow).
    ///
    /// Advances focus through the form fields in order:
    /// `SessionName` → `KeyOption` → `Submit` → wraps to `SessionName`
    NextField,

    /// Move focus to the previous field (Shift+Tab/Up arrow).
    ///
    /// Moves focus backwards through the form fields:
    /// `Submit` → `KeyOption` → `SessionName` → wraps to `Submit`
    PreviousField,

    /// Toggle the current option (Space/Enter on KeyOption, Left/Right arrows).
    ///
    /// Generated when the key option selector is focused and the user presses
    /// Space, Enter, or arrow keys. Toggles between "Use existing" and
    /// "Generate new" options.
    ToggleOption,

    /// Submit the form (Enter/Space on Submit button).
    ///
    /// Generated when the submit button is focused and the user presses
    /// Enter or Space. This triggers form validation and, if successful,
    /// transitions to the dashboard screen.
    Submit,

    /// Cancel and quit the application (Escape, Ctrl+C, or 'q' on non-text fields).
    ///
    /// Generated by:
    /// - Escape key (any field)
    /// - Ctrl+C (any field)
    /// - 'q' key (only when KeyOption or Submit is focused, not SessionName)
    Quit,

    /// No action (unhandled key combination).
    ///
    /// Returned when the key press is not mapped to any action in the current
    /// context. The application should ignore this and continue normally.
    None,
}

/// Processes a key event in the context of the setup form.
///
/// Translates raw keyboard input into semantic actions based on the currently
/// focused form field. The same key may produce different actions depending
/// on context—for example, 'q' quits when on the submit button but inserts
/// the character 'q' when typing in the session name field.
///
/// # Arguments
///
/// * `key_event` - The keyboard event from crossterm
/// * `focused_field` - The currently focused form field
///
/// # Returns
///
/// A [`SetupAction`] representing the user's intent.
///
/// # Field-Specific Behavior
///
/// ## SessionName (text input)
///
/// | Key | Action |
/// |-----|--------|
/// | Printable ASCII | `InsertChar(c)` |
/// | Non-ASCII | `None` |
/// | Backspace | `DeleteChar` |
/// | Tab, Down | `NextField` |
/// | Shift+Tab, Up | `PreviousField` |
/// | Enter | `NextField` |
/// | Escape | `Quit` |
/// | Ctrl+C | `Quit` |
///
/// ## KeyOption (toggle selector)
///
/// | Key | Action |
/// |-----|--------|
/// | Space, Enter | `ToggleOption` |
/// | Left, Right | `ToggleOption` |
/// | Tab, Down | `NextField` |
/// | Shift+Tab, Up | `PreviousField` |
/// | 'q' | `Quit` |
/// | Escape | `Quit` |
/// | Ctrl+C | `Quit` |
///
/// ## Submit (button)
///
/// | Key | Action |
/// |-----|--------|
/// | Space, Enter | `Submit` |
/// | Tab, Down | `NextField` |
/// | Shift+Tab, Up | `PreviousField` |
/// | 'q' | `Quit` |
/// | Escape | `Quit` |
/// | Ctrl+C | `Quit` |
///
/// # Example
///
/// ```
/// use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
/// use vibetea_monitor::tui::app::SetupField;
/// use vibetea_monitor::tui::input::{SetupAction, handle_setup_key};
///
/// // Tab advances to next field from any field
/// let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE);
/// assert_eq!(handle_setup_key(key, SetupField::SessionName), SetupAction::NextField);
/// assert_eq!(handle_setup_key(key, SetupField::KeyOption), SetupAction::NextField);
/// assert_eq!(handle_setup_key(key, SetupField::Submit), SetupAction::NextField);
///
/// // 'q' only quits on non-text fields
/// let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
/// assert_eq!(handle_setup_key(key, SetupField::SessionName), SetupAction::InsertChar('q'));
/// assert_eq!(handle_setup_key(key, SetupField::KeyOption), SetupAction::Quit);
/// assert_eq!(handle_setup_key(key, SetupField::Submit), SetupAction::Quit);
/// ```
#[must_use]
pub fn handle_setup_key(key_event: KeyEvent, focused_field: SetupField) -> SetupAction {
    // Global handlers (work on any field)
    if let Some(action) = handle_global_key(&key_event) {
        return action;
    }

    // Field-specific handlers
    match focused_field {
        SetupField::SessionName => handle_session_name_key(&key_event),
        SetupField::KeyOption => handle_key_option_key(&key_event),
        SetupField::Submit => handle_submit_key(&key_event),
    }
}

/// Handles keys that work globally across all fields.
///
/// Returns `Some(action)` for global keys (Escape, Ctrl+C), or `None` to
/// indicate the key should be handled by field-specific logic.
fn handle_global_key(key_event: &KeyEvent) -> Option<SetupAction> {
    match key_event.code {
        // Escape always quits
        KeyCode::Esc => Some(SetupAction::Quit),

        // Ctrl+C always quits
        KeyCode::Char('c') if key_event.modifiers.contains(KeyModifiers::CONTROL) => {
            Some(SetupAction::Quit)
        }

        // Not a global key
        _ => None,
    }
}

/// Handles keys when the session name text field is focused.
fn handle_session_name_key(key_event: &KeyEvent) -> SetupAction {
    match key_event.code {
        // Navigation
        KeyCode::Tab => {
            if key_event.modifiers.contains(KeyModifiers::SHIFT) {
                SetupAction::PreviousField
            } else {
                SetupAction::NextField
            }
        }
        KeyCode::Down => SetupAction::NextField,
        KeyCode::Up => SetupAction::PreviousField,

        // Enter moves to next field (not submit) when in text field
        KeyCode::Enter => SetupAction::NextField,

        // Text editing
        KeyCode::Backspace => SetupAction::DeleteChar,

        // Character input - only accept printable ASCII without control/alt modifiers
        KeyCode::Char(c) => {
            // Reject if control or alt modifier is present (shift is normal for uppercase)
            if key_event.modifiers.contains(KeyModifiers::CONTROL)
                || key_event.modifiers.contains(KeyModifiers::ALT)
            {
                return SetupAction::None;
            }
            if c.is_ascii() && !c.is_ascii_control() {
                SetupAction::InsertChar(c)
            } else {
                // Non-ASCII characters are rejected
                SetupAction::None
            }
        }

        // Unhandled key
        _ => SetupAction::None,
    }
}

/// Handles keys when the key option selector is focused.
fn handle_key_option_key(key_event: &KeyEvent) -> SetupAction {
    match key_event.code {
        // Navigation
        KeyCode::Tab => {
            if key_event.modifiers.contains(KeyModifiers::SHIFT) {
                SetupAction::PreviousField
            } else {
                SetupAction::NextField
            }
        }
        KeyCode::Down => SetupAction::NextField,
        KeyCode::Up => SetupAction::PreviousField,

        // Toggle selection
        KeyCode::Char(' ') => SetupAction::ToggleOption,
        KeyCode::Enter => SetupAction::ToggleOption,
        KeyCode::Left => SetupAction::ToggleOption,
        KeyCode::Right => SetupAction::ToggleOption,

        // Quick quit with 'q' (not typing in a text field)
        KeyCode::Char('q') => SetupAction::Quit,

        // Unhandled key
        _ => SetupAction::None,
    }
}

/// Handles keys when the submit button is focused.
fn handle_submit_key(key_event: &KeyEvent) -> SetupAction {
    match key_event.code {
        // Navigation
        KeyCode::Tab => {
            if key_event.modifiers.contains(KeyModifiers::SHIFT) {
                SetupAction::PreviousField
            } else {
                SetupAction::NextField
            }
        }
        KeyCode::Down => SetupAction::NextField,
        KeyCode::Up => SetupAction::PreviousField,

        // Submit form
        KeyCode::Char(' ') => SetupAction::Submit,
        KeyCode::Enter => SetupAction::Submit,

        // Quick quit with 'q' (not typing in a text field)
        KeyCode::Char('q') => SetupAction::Quit,

        // Unhandled key
        _ => SetupAction::None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // =========================================================================
    // SetupAction Tests
    // =========================================================================

    #[test]
    fn setup_action_is_debug() {
        let action = SetupAction::InsertChar('a');
        let debug_str = format!("{:?}", action);
        assert!(debug_str.contains("InsertChar"));
        assert!(debug_str.contains('a'));
    }

    #[test]
    fn setup_action_is_clone() {
        let action = SetupAction::NextField;
        let cloned = action.clone();
        assert_eq!(action, cloned);
    }

    #[test]
    fn setup_action_is_eq() {
        assert_eq!(SetupAction::NextField, SetupAction::NextField);
        assert_eq!(SetupAction::InsertChar('a'), SetupAction::InsertChar('a'));
        assert_ne!(SetupAction::InsertChar('a'), SetupAction::InsertChar('b'));
        assert_ne!(SetupAction::NextField, SetupAction::PreviousField);
    }

    #[test]
    fn setup_action_variants_are_distinct() {
        let variants = [
            SetupAction::InsertChar('x'),
            SetupAction::DeleteChar,
            SetupAction::NextField,
            SetupAction::PreviousField,
            SetupAction::ToggleOption,
            SetupAction::Submit,
            SetupAction::Quit,
            SetupAction::None,
        ];

        // Each variant should be distinct from others (except InsertChar with itself)
        for (i, a) in variants.iter().enumerate() {
            for (j, b) in variants.iter().enumerate() {
                if i == j {
                    assert_eq!(a, b);
                } else {
                    assert_ne!(a, b, "Variants at {} and {} should differ", i, j);
                }
            }
        }
    }

    // =========================================================================
    // Global Key Handling Tests
    // =========================================================================

    #[test]
    fn escape_quits_from_session_name() {
        let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn escape_quits_from_key_option() {
        let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn escape_quits_from_submit() {
        let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn ctrl_c_quits_from_session_name() {
        let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn ctrl_c_quits_from_key_option() {
        let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn ctrl_c_quits_from_submit() {
        let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::Quit);
    }

    // =========================================================================
    // SessionName Field Tests - Character Insertion
    // =========================================================================

    #[test]
    fn session_name_inserts_lowercase_letter() {
        let key = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('a'));
    }

    #[test]
    fn session_name_inserts_uppercase_letter() {
        let key = KeyEvent::new(KeyCode::Char('Z'), KeyModifiers::SHIFT);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('Z'));
    }

    #[test]
    fn session_name_inserts_digit() {
        let key = KeyEvent::new(KeyCode::Char('5'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('5'));
    }

    #[test]
    fn session_name_inserts_hyphen() {
        let key = KeyEvent::new(KeyCode::Char('-'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('-'));
    }

    #[test]
    fn session_name_inserts_underscore() {
        let key = KeyEvent::new(KeyCode::Char('_'), KeyModifiers::SHIFT);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('_'));
    }

    #[test]
    fn session_name_inserts_space() {
        // Space is a valid ASCII character; validation is separate from input
        let key = KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar(' '));
    }

    #[test]
    fn session_name_inserts_q_character() {
        // 'q' should insert, not quit, when in text field
        let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::InsertChar('q'));
    }

    // =========================================================================
    // SessionName Field Tests - Backspace
    // =========================================================================

    #[test]
    fn session_name_backspace_deletes() {
        let key = KeyEvent::new(KeyCode::Backspace, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::DeleteChar);
    }

    // =========================================================================
    // SessionName Field Tests - Navigation
    // =========================================================================

    #[test]
    fn session_name_tab_goes_to_next_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn session_name_shift_tab_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::SHIFT);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::PreviousField);
    }

    #[test]
    fn session_name_down_arrow_goes_to_next_field() {
        let key = KeyEvent::new(KeyCode::Down, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn session_name_up_arrow_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Up, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::PreviousField);
    }

    #[test]
    fn session_name_enter_goes_to_next_field_not_submit() {
        // Enter on text field should navigate, not submit
        let key = KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::NextField);
    }

    // =========================================================================
    // KeyOption Field Tests - Toggle
    // =========================================================================

    #[test]
    fn key_option_space_toggles() {
        let key = KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::ToggleOption);
    }

    #[test]
    fn key_option_enter_toggles() {
        let key = KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::ToggleOption);
    }

    #[test]
    fn key_option_left_arrow_toggles() {
        let key = KeyEvent::new(KeyCode::Left, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::ToggleOption);
    }

    #[test]
    fn key_option_right_arrow_toggles() {
        let key = KeyEvent::new(KeyCode::Right, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::ToggleOption);
    }

    // =========================================================================
    // KeyOption Field Tests - Navigation
    // =========================================================================

    #[test]
    fn key_option_tab_goes_to_next_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn key_option_shift_tab_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::SHIFT);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::PreviousField);
    }

    #[test]
    fn key_option_down_arrow_goes_to_next_field() {
        let key = KeyEvent::new(KeyCode::Down, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn key_option_up_arrow_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Up, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::PreviousField);
    }

    // =========================================================================
    // KeyOption Field Tests - Quit
    // =========================================================================

    #[test]
    fn key_option_q_quits() {
        let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::Quit);
    }

    // =========================================================================
    // Submit Field Tests - Submit
    // =========================================================================

    #[test]
    fn submit_space_submits() {
        let key = KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::Submit);
    }

    #[test]
    fn submit_enter_submits() {
        let key = KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::Submit);
    }

    // =========================================================================
    // Submit Field Tests - Navigation
    // =========================================================================

    #[test]
    fn submit_tab_wraps_to_next_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn submit_shift_tab_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::SHIFT);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::PreviousField);
    }

    #[test]
    fn submit_down_arrow_goes_to_next_field() {
        let key = KeyEvent::new(KeyCode::Down, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::NextField);
    }

    #[test]
    fn submit_up_arrow_goes_to_previous_field() {
        let key = KeyEvent::new(KeyCode::Up, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::PreviousField);
    }

    // =========================================================================
    // Submit Field Tests - Quit
    // =========================================================================

    #[test]
    fn submit_q_quits() {
        let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::Quit);
    }

    // =========================================================================
    // Unhandled Key Tests
    // =========================================================================

    #[test]
    fn session_name_f1_returns_none() {
        let key = KeyEvent::new(KeyCode::F(1), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn key_option_letter_returns_none() {
        // Non-q letters should be ignored on KeyOption field
        let key = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn submit_letter_returns_none() {
        // Non-q letters should be ignored on Submit field
        let key = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn home_key_returns_none() {
        let key = KeyEvent::new(KeyCode::Home, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn page_down_returns_none() {
        let key = KeyEvent::new(KeyCode::PageDown, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::None);
    }

    // =========================================================================
    // Edge Cases
    // =========================================================================

    #[test]
    fn session_name_ctrl_a_does_not_insert() {
        // Ctrl+A should not insert 'a'
        let key = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL);
        let action = handle_setup_key(key, SetupField::SessionName);
        // Control characters are filtered out
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn alt_modifiers_are_filtered() {
        // Alt+letter should not insert in text field (reserved for shortcuts)
        let key = KeyEvent::new(KeyCode::Char('x'), KeyModifiers::ALT);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn delete_key_returns_none_on_session_name() {
        // Delete (forward delete) is not implemented, returns None
        let key = KeyEvent::new(KeyCode::Delete, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn backspace_on_key_option_returns_none() {
        // Backspace is only meaningful on text fields
        let key = KeyEvent::new(KeyCode::Backspace, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::KeyOption);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn backspace_on_submit_returns_none() {
        let key = KeyEvent::new(KeyCode::Backspace, KeyModifiers::NONE);
        let action = handle_setup_key(key, SetupField::Submit);
        assert_eq!(action, SetupAction::None);
    }

    #[test]
    fn ctrl_c_takes_priority_over_character_insertion() {
        // Even though 'c' is a valid character, Ctrl+C should quit
        let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL);
        let action = handle_setup_key(key, SetupField::SessionName);
        assert_eq!(action, SetupAction::Quit);
    }

    #[test]
    fn escape_takes_priority_over_field_handling() {
        // Escape should quit regardless of field
        for field in [
            SetupField::SessionName,
            SetupField::KeyOption,
            SetupField::Submit,
        ] {
            let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
            let action = handle_setup_key(key, field);
            assert_eq!(
                action,
                SetupAction::Quit,
                "Escape should quit on {:?}",
                field
            );
        }
    }

    // =========================================================================
    // Comprehensive Navigation Tests
    // =========================================================================

    #[test]
    fn tab_navigates_forward_through_all_fields() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE);

        // All fields should produce NextField on Tab
        assert_eq!(
            handle_setup_key(key, SetupField::SessionName),
            SetupAction::NextField
        );
        assert_eq!(
            handle_setup_key(key, SetupField::KeyOption),
            SetupAction::NextField
        );
        assert_eq!(
            handle_setup_key(key, SetupField::Submit),
            SetupAction::NextField
        );
    }

    #[test]
    fn shift_tab_navigates_backward_through_all_fields() {
        let key = KeyEvent::new(KeyCode::Tab, KeyModifiers::SHIFT);

        // All fields should produce PreviousField on Shift+Tab
        assert_eq!(
            handle_setup_key(key, SetupField::SessionName),
            SetupAction::PreviousField
        );
        assert_eq!(
            handle_setup_key(key, SetupField::KeyOption),
            SetupAction::PreviousField
        );
        assert_eq!(
            handle_setup_key(key, SetupField::Submit),
            SetupAction::PreviousField
        );
    }

    #[test]
    fn q_behavior_differs_by_field_type() {
        let key = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);

        // Text field: insert character
        assert_eq!(
            handle_setup_key(key, SetupField::SessionName),
            SetupAction::InsertChar('q')
        );

        // Non-text fields: quit
        assert_eq!(
            handle_setup_key(key, SetupField::KeyOption),
            SetupAction::Quit
        );
        assert_eq!(handle_setup_key(key, SetupField::Submit), SetupAction::Quit);
    }
}
