//! Application state and event management for the VibeTea Monitor TUI.
//!
//! This module contains the core application state, event types, and business logic
//! that drive the TUI. The main types are:
//!
//! - [`TuiEvent`]: Events that drive the TUI event loop
//! - [`EventStats`]: Metrics for sender event throughput (placeholder)
//! - [`ConnectionStatus`]: WebSocket connection state (placeholder)
//!
//! # Architecture
//!
//! The TUI uses an event-driven architecture where all state changes are triggered
//! by [`TuiEvent`] variants. Events are processed in the main loop and result in
//! state updates followed by render cycles.

use crossterm::event::KeyEvent;

use crate::types::Event;

/// Statistics for event sending throughput.
///
/// Tracks metrics about events being sent to the VibeTea server,
/// including counts, rates, and timing information.
///
/// # Note
///
/// This is a placeholder type. The full implementation will be added
/// in a later task with fields for event counts, throughput rates,
/// success/failure tracking, and timing statistics.
#[derive(Debug, Clone, Default, PartialEq)]
pub struct EventStats {
    /// Total number of events sent successfully.
    pub events_sent: u64,
    /// Total number of events that failed to send.
    pub events_failed: u64,
}

/// Connection status for the WebSocket link to the VibeTea server.
///
/// Represents the current state of the connection to the server,
/// allowing the TUI to display appropriate status indicators.
///
/// # Note
///
/// This is a placeholder type. Additional variants and associated data
/// (such as error details, retry counts, or latency measurements) may be
/// added in later tasks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ConnectionStatus {
    /// Not connected to the server.
    #[default]
    Disconnected,
    /// Currently attempting to establish a connection.
    Connecting,
    /// Successfully connected and ready to send events.
    Connected,
    /// Connection attempt failed or connection was lost.
    Error,
}

/// Events that drive the TUI event loop.
///
/// The TUI operates on an event-driven model where all state changes
/// are triggered by incoming events. This enum defines all possible
/// event types that the main loop can process.
///
/// # Event Sources
///
/// - **Tick**: Generated by an internal timer for animations and periodic updates
/// - **Render**: Triggered when a redraw is needed
/// - **Key**: Forwarded from terminal input handling
/// - **Resize**: Forwarded from terminal resize signals
/// - **WatchEvent**: Forwarded from the file watcher monitoring session logs
/// - **MetricsUpdate**: Received from the sender component with throughput stats
/// - **ConnectionChange**: Received when WebSocket connection state changes
///
/// # Examples
///
/// ```ignore
/// use vibetea_monitor::tui::app::TuiEvent;
/// use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
///
/// // Handle a key press event
/// let event = TuiEvent::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
///
/// // Handle a resize event
/// let event = TuiEvent::Resize(120, 40);
/// ```
#[derive(Debug, Clone)]
pub enum TuiEvent {
    /// Periodic tick for animations and timers.
    ///
    /// Generated at a fixed interval (default 60ms) to drive animations,
    /// update timers, and perform periodic state checks.
    Tick,

    /// Trigger a render cycle.
    ///
    /// Indicates that the UI should be redrawn. This may be triggered
    /// after state changes or when the terminal needs refreshing.
    Render,

    /// Terminal input event.
    ///
    /// Represents a key press or key combination from the user.
    /// The TUI processes these to handle navigation, commands, and input.
    Key(KeyEvent),

    /// Terminal resize event.
    ///
    /// Contains the new terminal dimensions (columns, rows) after a resize.
    /// The TUI should recalculate layouts and redraw when this is received.
    Resize(u16, u16),

    /// File watcher event.
    ///
    /// Forwarded from the existing file watcher when new session events
    /// are detected in the monitored log files.
    WatchEvent(Event),

    /// Sender metrics update.
    ///
    /// Contains updated statistics about event sending throughput,
    /// success rates, and other sender-related metrics.
    MetricsUpdate(EventStats),

    /// Connection status change.
    ///
    /// Indicates that the WebSocket connection state has changed,
    /// allowing the TUI to update status indicators accordingly.
    ConnectionChange(ConnectionStatus),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{KeyCode, KeyModifiers};

    #[test]
    fn event_stats_default() {
        let stats = EventStats::default();
        assert_eq!(stats.events_sent, 0);
        assert_eq!(stats.events_failed, 0);
    }

    #[test]
    fn connection_status_default_is_disconnected() {
        let status = ConnectionStatus::default();
        assert_eq!(status, ConnectionStatus::Disconnected);
    }

    #[test]
    fn tui_event_tick_is_debug() {
        let event = TuiEvent::Tick;
        let debug_str = format!("{:?}", event);
        assert!(debug_str.contains("Tick"));
    }

    #[test]
    fn tui_event_render_is_clone() {
        let event = TuiEvent::Render;
        let cloned = event.clone();
        assert!(matches!(cloned, TuiEvent::Render));
    }

    #[test]
    fn tui_event_key_wraps_key_event() {
        let key_event = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        let event = TuiEvent::Key(key_event);

        if let TuiEvent::Key(k) = event {
            assert_eq!(k.code, KeyCode::Char('q'));
            assert_eq!(k.modifiers, KeyModifiers::NONE);
        } else {
            panic!("Expected TuiEvent::Key variant");
        }
    }

    #[test]
    fn tui_event_resize_contains_dimensions() {
        let event = TuiEvent::Resize(120, 40);

        if let TuiEvent::Resize(cols, rows) = event {
            assert_eq!(cols, 120);
            assert_eq!(rows, 40);
        } else {
            panic!("Expected TuiEvent::Resize variant");
        }
    }

    #[test]
    fn tui_event_metrics_update_contains_stats() {
        let stats = EventStats {
            events_sent: 100,
            events_failed: 5,
        };
        let event = TuiEvent::MetricsUpdate(stats.clone());

        if let TuiEvent::MetricsUpdate(s) = event {
            assert_eq!(s.events_sent, 100);
            assert_eq!(s.events_failed, 5);
        } else {
            panic!("Expected TuiEvent::MetricsUpdate variant");
        }
    }

    #[test]
    fn tui_event_connection_change_contains_status() {
        let event = TuiEvent::ConnectionChange(ConnectionStatus::Connected);

        if let TuiEvent::ConnectionChange(status) = event {
            assert_eq!(status, ConnectionStatus::Connected);
        } else {
            panic!("Expected TuiEvent::ConnectionChange variant");
        }
    }
}
