//! Application state and event management for the VibeTea Monitor TUI.
//!
//! This module contains the core application state, event types, and business logic
//! that drive the TUI. The main types are:
//!
//! - [`TuiEvent`]: Events that drive the TUI event loop
//! - [`EventHandler`]: Async event loop using `tokio::select!` to multiplex event sources
//! - [`EventStats`]: Metrics for sender event throughput (placeholder)
//! - [`ConnectionStatus`]: WebSocket connection state (placeholder)
//!
//! # Architecture
//!
//! The TUI uses an event-driven architecture where all state changes are triggered
//! by [`TuiEvent`] variants. The [`EventHandler`] runs an async loop that:
//!
//! 1. Polls for terminal input (keyboard, resize) with short timeouts
//! 2. Generates periodic tick events for animations and timers
//! 3. Listens for shutdown signals to terminate gracefully
//!
//! Events are sent to the main application via an MPSC channel, where they are
//! processed to update state followed by render cycles.
//!
//! # Example
//!
//! ```ignore
//! use tokio::sync::mpsc;
//! use vibetea_monitor::tui::app::EventHandler;
//!
//! let (event_tx, mut event_rx) = mpsc::channel(100);
//! let (shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel();
//!
//! // Spawn the event handler
//! let handler = EventHandler::new(event_tx, shutdown_rx);
//! tokio::spawn(handler.run());
//!
//! // Process events in the main loop
//! while let Some(event) = event_rx.recv().await {
//!     // Handle the event...
//! }
//! ```

use std::time::Duration;

use crossterm::event::{self, Event as CrosstermEvent, KeyEvent};
use tokio::sync::{mpsc, oneshot};

use crate::types::Event;

/// Statistics for event sending throughput.
///
/// Tracks metrics about events being sent to the VibeTea server,
/// including counts, rates, and timing information.
///
/// # Note
///
/// This is a placeholder type. The full implementation will be added
/// in a later task with fields for event counts, throughput rates,
/// success/failure tracking, and timing statistics.
#[derive(Debug, Clone, Default, PartialEq)]
pub struct EventStats {
    /// Total number of events sent successfully.
    pub events_sent: u64,
    /// Total number of events that failed to send.
    pub events_failed: u64,
}

/// Connection status for the WebSocket link to the VibeTea server.
///
/// Represents the current state of the connection to the server,
/// allowing the TUI to display appropriate status indicators.
///
/// # Note
///
/// This is a placeholder type. Additional variants and associated data
/// (such as error details, retry counts, or latency measurements) may be
/// added in later tasks.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ConnectionStatus {
    /// Not connected to the server.
    #[default]
    Disconnected,
    /// Currently attempting to establish a connection.
    Connecting,
    /// Successfully connected and ready to send events.
    Connected,
    /// Connection attempt failed or connection was lost.
    Error,
}

/// Events that drive the TUI event loop.
///
/// The TUI operates on an event-driven model where all state changes
/// are triggered by incoming events. This enum defines all possible
/// event types that the main loop can process.
///
/// # Event Sources
///
/// - **Tick**: Generated by an internal timer for animations and periodic updates
/// - **Render**: Triggered when a redraw is needed
/// - **Key**: Forwarded from terminal input handling
/// - **Resize**: Forwarded from terminal resize signals
/// - **WatchEvent**: Forwarded from the file watcher monitoring session logs
/// - **MetricsUpdate**: Received from the sender component with throughput stats
/// - **ConnectionChange**: Received when WebSocket connection state changes
///
/// # Examples
///
/// ```ignore
/// use vibetea_monitor::tui::app::TuiEvent;
/// use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
///
/// // Handle a key press event
/// let event = TuiEvent::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
///
/// // Handle a resize event
/// let event = TuiEvent::Resize(120, 40);
/// ```
#[derive(Debug, Clone)]
pub enum TuiEvent {
    /// Periodic tick for animations and timers.
    ///
    /// Generated at a fixed interval (default 60ms) to drive animations,
    /// update timers, and perform periodic state checks.
    Tick,

    /// Trigger a render cycle.
    ///
    /// Indicates that the UI should be redrawn. This may be triggered
    /// after state changes or when the terminal needs refreshing.
    Render,

    /// Terminal input event.
    ///
    /// Represents a key press or key combination from the user.
    /// The TUI processes these to handle navigation, commands, and input.
    Key(KeyEvent),

    /// Terminal resize event.
    ///
    /// Contains the new terminal dimensions (columns, rows) after a resize.
    /// The TUI should recalculate layouts and redraw when this is received.
    Resize(u16, u16),

    /// File watcher event.
    ///
    /// Forwarded from the existing file watcher when new session events
    /// are detected in the monitored log files.
    WatchEvent(Event),

    /// Sender metrics update.
    ///
    /// Contains updated statistics about event sending throughput,
    /// success rates, and other sender-related metrics.
    MetricsUpdate(EventStats),

    /// Connection status change.
    ///
    /// Indicates that the WebSocket connection state has changed,
    /// allowing the TUI to update status indicators accordingly.
    ConnectionChange(ConnectionStatus),
}

/// Default tick rate for the event handler (60ms = ~16 FPS).
///
/// This value provides smooth animations while balancing CPU usage.
/// A faster tick rate (lower value) provides smoother animations but
/// consumes more CPU cycles polling for events.
pub const DEFAULT_TICK_RATE_MS: u64 = 60;

/// Default poll timeout for checking terminal input (10ms).
///
/// This short timeout allows the event loop to remain responsive to
/// shutdown signals while efficiently batching terminal events.
const DEFAULT_POLL_TIMEOUT_MS: u64 = 10;

/// Handles terminal input and generates periodic tick events.
///
/// The `EventHandler` runs an async event loop that:
///
/// 1. Polls for terminal input (key presses, resize events) with a short timeout
/// 2. Generates [`TuiEvent::Tick`] events at a configurable interval
/// 3. Sends all events to the main application via an MPSC channel
/// 4. Terminates gracefully when a shutdown signal is received
///
/// # Architecture
///
/// The handler uses `tokio::select!` to multiplex three event sources:
///
/// - **Tick interval**: A tokio interval that fires at the configured tick rate
/// - **Terminal polling**: Non-blocking checks for crossterm events
/// - **Shutdown signal**: A oneshot channel that triggers graceful termination
///
/// # Thread Safety
///
/// The `EventHandler` is designed to run in its own tokio task. It uses
/// `tokio::task::spawn_blocking` for terminal polling to avoid blocking
/// the async runtime with synchronous crossterm calls.
///
/// # Example
///
/// ```ignore
/// use tokio::sync::{mpsc, oneshot};
/// use vibetea_monitor::tui::app::EventHandler;
///
/// async fn run_tui() {
///     let (event_tx, mut event_rx) = mpsc::channel(100);
///     let (shutdown_tx, shutdown_rx) = oneshot::channel();
///
///     // Spawn the event handler in a separate task
///     let handler = EventHandler::new(event_tx, shutdown_rx);
///     let event_task = tokio::spawn(handler.run());
///
///     // Main application loop
///     while let Some(event) = event_rx.recv().await {
///         match event {
///             TuiEvent::Tick => { /* update timers, animations */ }
///             TuiEvent::Key(key) => { /* handle input */ }
///             TuiEvent::Resize(w, h) => { /* recalculate layout */ }
///             _ => {}
///         }
///     }
///
///     // Trigger shutdown
///     let _ = shutdown_tx.send(());
///     event_task.await.unwrap();
/// }
/// ```
#[derive(Debug)]
pub struct EventHandler {
    /// Channel sender for dispatching events to the main application.
    event_tx: mpsc::Sender<TuiEvent>,
    /// Receiver for the shutdown signal.
    shutdown_rx: oneshot::Receiver<()>,
    /// Tick rate in milliseconds.
    tick_rate: Duration,
}

impl EventHandler {
    /// Creates a new `EventHandler` with the default tick rate.
    ///
    /// # Arguments
    ///
    /// * `event_tx` - Channel sender for dispatching [`TuiEvent`]s to the application
    /// * `shutdown_rx` - Oneshot receiver that signals when the handler should terminate
    ///
    /// # Example
    ///
    /// ```ignore
    /// use tokio::sync::{mpsc, oneshot};
    /// use vibetea_monitor::tui::app::EventHandler;
    ///
    /// let (event_tx, event_rx) = mpsc::channel(100);
    /// let (shutdown_tx, shutdown_rx) = oneshot::channel();
    ///
    /// let handler = EventHandler::new(event_tx, shutdown_rx);
    /// ```
    pub fn new(event_tx: mpsc::Sender<TuiEvent>, shutdown_rx: oneshot::Receiver<()>) -> Self {
        Self {
            event_tx,
            shutdown_rx,
            tick_rate: Duration::from_millis(DEFAULT_TICK_RATE_MS),
        }
    }

    /// Creates a new `EventHandler` with a custom tick rate.
    ///
    /// # Arguments
    ///
    /// * `event_tx` - Channel sender for dispatching [`TuiEvent`]s to the application
    /// * `shutdown_rx` - Oneshot receiver that signals when the handler should terminate
    /// * `tick_rate` - Custom tick rate for generating [`TuiEvent::Tick`] events
    ///
    /// # Example
    ///
    /// ```ignore
    /// use std::time::Duration;
    /// use tokio::sync::{mpsc, oneshot};
    /// use vibetea_monitor::tui::app::EventHandler;
    ///
    /// let (event_tx, event_rx) = mpsc::channel(100);
    /// let (shutdown_tx, shutdown_rx) = oneshot::channel();
    ///
    /// // Create a handler with 30 FPS (~33ms tick rate)
    /// let handler = EventHandler::with_tick_rate(event_tx, shutdown_rx, Duration::from_millis(33));
    /// ```
    pub fn with_tick_rate(
        event_tx: mpsc::Sender<TuiEvent>,
        shutdown_rx: oneshot::Receiver<()>,
        tick_rate: Duration,
    ) -> Self {
        Self {
            event_tx,
            shutdown_rx,
            tick_rate,
        }
    }

    /// Returns the configured tick rate.
    pub fn tick_rate(&self) -> Duration {
        self.tick_rate
    }

    /// Runs the event loop until a shutdown signal is received.
    ///
    /// This method consumes the `EventHandler` and runs until either:
    /// - A shutdown signal is received via the `shutdown_rx` channel
    /// - The event sender is closed (all receivers dropped)
    ///
    /// # Event Generation
    ///
    /// The loop generates events in the following priority order:
    ///
    /// 1. **Shutdown check**: If a shutdown signal is received, exit immediately
    /// 2. **Tick events**: Generate [`TuiEvent::Tick`] at the configured interval
    /// 3. **Terminal events**: Poll for key presses and resize events
    ///
    /// # Errors
    ///
    /// Returns `Ok(())` on graceful shutdown. Returns an error if:
    /// - Terminal event polling fails (I/O error)
    /// - The event channel is closed unexpectedly
    ///
    /// # Example
    ///
    /// ```ignore
    /// use tokio::sync::{mpsc, oneshot};
    /// use vibetea_monitor::tui::app::EventHandler;
    ///
    /// async fn example() {
    ///     let (event_tx, mut event_rx) = mpsc::channel(100);
    ///     let (shutdown_tx, shutdown_rx) = oneshot::channel();
    ///
    ///     let handler = EventHandler::new(event_tx, shutdown_rx);
    ///
    ///     // Run in a spawned task
    ///     tokio::spawn(async move {
    ///         if let Err(e) = handler.run().await {
    ///             eprintln!("Event handler error: {}", e);
    ///         }
    ///     });
    ///
    ///     // Process events...
    ///     while let Some(event) = event_rx.recv().await {
    ///         // handle event
    ///     }
    ///
    ///     // Signal shutdown
    ///     let _ = shutdown_tx.send(());
    /// }
    /// ```
    pub async fn run(mut self) -> std::io::Result<()> {
        let mut tick_interval = tokio::time::interval(self.tick_rate);
        // Use burst mode to avoid tick accumulation if processing falls behind
        tick_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Burst);

        // Consume the first tick immediately (interval ticks immediately on creation)
        tick_interval.tick().await;

        loop {
            // Use biased selection to ensure shutdown is always checked first
            tokio::select! {
                biased;

                // Highest priority: check for shutdown signal
                _ = &mut self.shutdown_rx => {
                    tracing::debug!("EventHandler received shutdown signal");
                    break;
                }

                // Generate tick events at the configured interval
                _ = tick_interval.tick() => {
                    if self.event_tx.send(TuiEvent::Tick).await.is_err() {
                        // Receiver dropped, exit gracefully
                        tracing::debug!("Event receiver dropped, exiting event loop");
                        break;
                    }
                }

                // Poll for terminal events with a short sleep to prevent busy-waiting
                // We use spawn_blocking to avoid blocking the async runtime
                result = async {
                    // Small delay before polling to allow tick events to be processed
                    tokio::time::sleep(Duration::from_millis(DEFAULT_POLL_TIMEOUT_MS)).await;
                    tokio::task::spawn_blocking(|| {
                        Self::poll_terminal_event(Duration::from_millis(DEFAULT_POLL_TIMEOUT_MS))
                    }).await
                } => {
                    match result {
                        Ok(Some(event)) => {
                            if self.event_tx.send(event).await.is_err() {
                                tracing::debug!("Event receiver dropped, exiting event loop");
                                break;
                            }
                        }
                        Ok(None) => {
                            // No event available within timeout, continue
                        }
                        Err(join_error) => {
                            tracing::error!("spawn_blocking task panicked: {}", join_error);
                            return Err(std::io::Error::other(
                                "Terminal polling task panicked",
                            ));
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Polls for a terminal event with the specified timeout.
    ///
    /// This is a synchronous function designed to be called via `spawn_blocking`
    /// to avoid blocking the async runtime.
    ///
    /// # Returns
    ///
    /// - `Ok(Some(event))` if a terminal event was received
    /// - `Ok(None)` if the timeout elapsed with no event, or if polling failed
    ///   due to non-terminal environment (e.g., in tests or CI)
    fn poll_terminal_event(timeout: Duration) -> Option<TuiEvent> {
        // In non-terminal environments (CI, tests), poll() may fail.
        // We treat this as "no event" rather than propagating the error.
        match event::poll(timeout) {
            Ok(true) => {
                // Event is available, try to read it
                match event::read() {
                    Ok(crossterm_event) => Self::convert_crossterm_event(crossterm_event),
                    Err(e) => {
                        tracing::trace!("Failed to read terminal event: {}", e);
                        None
                    }
                }
            }
            Ok(false) => {
                // No event within timeout
                None
            }
            Err(e) => {
                // Polling failed (likely no terminal available)
                tracing::trace!("Failed to poll terminal: {}", e);
                None
            }
        }
    }

    /// Converts a crossterm event to a TuiEvent.
    ///
    /// # Returns
    ///
    /// - `Some(TuiEvent)` for supported event types (Key, Resize)
    /// - `None` for unsupported event types (Mouse, Focus, Paste)
    fn convert_crossterm_event(event: CrosstermEvent) -> Option<TuiEvent> {
        match event {
            CrosstermEvent::Key(key_event) => Some(TuiEvent::Key(key_event)),
            CrosstermEvent::Resize(cols, rows) => Some(TuiEvent::Resize(cols, rows)),
            // Mouse events, focus events, and paste events are not currently handled
            CrosstermEvent::Mouse(_) => None,
            CrosstermEvent::FocusGained | CrosstermEvent::FocusLost => None,
            CrosstermEvent::Paste(_) => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{KeyCode, KeyModifiers};

    #[test]
    fn event_stats_default() {
        let stats = EventStats::default();
        assert_eq!(stats.events_sent, 0);
        assert_eq!(stats.events_failed, 0);
    }

    #[test]
    fn connection_status_default_is_disconnected() {
        let status = ConnectionStatus::default();
        assert_eq!(status, ConnectionStatus::Disconnected);
    }

    #[test]
    fn tui_event_tick_is_debug() {
        let event = TuiEvent::Tick;
        let debug_str = format!("{:?}", event);
        assert!(debug_str.contains("Tick"));
    }

    #[test]
    fn tui_event_render_is_clone() {
        let event = TuiEvent::Render;
        let cloned = event.clone();
        assert!(matches!(cloned, TuiEvent::Render));
    }

    #[test]
    fn tui_event_key_wraps_key_event() {
        let key_event = KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE);
        let event = TuiEvent::Key(key_event);

        if let TuiEvent::Key(k) = event {
            assert_eq!(k.code, KeyCode::Char('q'));
            assert_eq!(k.modifiers, KeyModifiers::NONE);
        } else {
            panic!("Expected TuiEvent::Key variant");
        }
    }

    #[test]
    fn tui_event_resize_contains_dimensions() {
        let event = TuiEvent::Resize(120, 40);

        if let TuiEvent::Resize(cols, rows) = event {
            assert_eq!(cols, 120);
            assert_eq!(rows, 40);
        } else {
            panic!("Expected TuiEvent::Resize variant");
        }
    }

    #[test]
    fn tui_event_metrics_update_contains_stats() {
        let stats = EventStats {
            events_sent: 100,
            events_failed: 5,
        };
        let event = TuiEvent::MetricsUpdate(stats.clone());

        if let TuiEvent::MetricsUpdate(s) = event {
            assert_eq!(s.events_sent, 100);
            assert_eq!(s.events_failed, 5);
        } else {
            panic!("Expected TuiEvent::MetricsUpdate variant");
        }
    }

    #[test]
    fn tui_event_connection_change_contains_status() {
        let event = TuiEvent::ConnectionChange(ConnectionStatus::Connected);

        if let TuiEvent::ConnectionChange(status) = event {
            assert_eq!(status, ConnectionStatus::Connected);
        } else {
            panic!("Expected TuiEvent::ConnectionChange variant");
        }
    }

    // EventHandler tests

    #[test]
    fn event_handler_new_has_default_tick_rate() {
        let (event_tx, _event_rx) = mpsc::channel(10);
        let (_shutdown_tx, shutdown_rx) = oneshot::channel();

        let handler = EventHandler::new(event_tx, shutdown_rx);
        assert_eq!(
            handler.tick_rate(),
            Duration::from_millis(DEFAULT_TICK_RATE_MS)
        );
    }

    #[test]
    fn event_handler_with_custom_tick_rate() {
        let (event_tx, _event_rx) = mpsc::channel(10);
        let (_shutdown_tx, shutdown_rx) = oneshot::channel();

        let custom_rate = Duration::from_millis(33);
        let handler = EventHandler::with_tick_rate(event_tx, shutdown_rx, custom_rate);
        assert_eq!(handler.tick_rate(), custom_rate);
    }

    #[test]
    fn event_handler_is_debug() {
        let (event_tx, _event_rx) = mpsc::channel(10);
        let (_shutdown_tx, shutdown_rx) = oneshot::channel();

        let handler = EventHandler::new(event_tx, shutdown_rx);
        let debug_str = format!("{:?}", handler);
        assert!(debug_str.contains("EventHandler"));
    }

    #[test]
    fn convert_crossterm_key_event() {
        let key_event = KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL);
        let crossterm_event = CrosstermEvent::Key(key_event);

        let result = EventHandler::convert_crossterm_event(crossterm_event);
        assert!(result.is_some());

        if let Some(TuiEvent::Key(k)) = result {
            assert_eq!(k.code, KeyCode::Char('a'));
            assert_eq!(k.modifiers, KeyModifiers::CONTROL);
        } else {
            panic!("Expected TuiEvent::Key variant");
        }
    }

    #[test]
    fn convert_crossterm_resize_event() {
        let crossterm_event = CrosstermEvent::Resize(80, 24);

        let result = EventHandler::convert_crossterm_event(crossterm_event);
        assert!(result.is_some());

        if let Some(TuiEvent::Resize(cols, rows)) = result {
            assert_eq!(cols, 80);
            assert_eq!(rows, 24);
        } else {
            panic!("Expected TuiEvent::Resize variant");
        }
    }

    #[test]
    fn convert_crossterm_mouse_event_returns_none() {
        use crossterm::event::{MouseEvent, MouseEventKind};

        let mouse_event = MouseEvent {
            kind: MouseEventKind::Down(crossterm::event::MouseButton::Left),
            column: 10,
            row: 5,
            modifiers: KeyModifiers::NONE,
        };
        let crossterm_event = CrosstermEvent::Mouse(mouse_event);

        let result = EventHandler::convert_crossterm_event(crossterm_event);
        assert!(result.is_none());
    }

    #[test]
    fn convert_crossterm_focus_events_return_none() {
        let focus_gained = CrosstermEvent::FocusGained;
        let focus_lost = CrosstermEvent::FocusLost;

        assert!(EventHandler::convert_crossterm_event(focus_gained).is_none());
        assert!(EventHandler::convert_crossterm_event(focus_lost).is_none());
    }

    #[test]
    fn convert_crossterm_paste_event_returns_none() {
        let crossterm_event = CrosstermEvent::Paste("clipboard content".to_string());

        let result = EventHandler::convert_crossterm_event(crossterm_event);
        assert!(result.is_none());
    }

    #[test]
    fn default_tick_rate_is_60ms() {
        assert_eq!(DEFAULT_TICK_RATE_MS, 60);
    }

    #[tokio::test]
    async fn event_handler_stops_on_shutdown_signal() {
        let (event_tx, _event_rx) = mpsc::channel(100);
        let (shutdown_tx, shutdown_rx) = oneshot::channel();

        let handler = EventHandler::with_tick_rate(
            event_tx,
            shutdown_rx,
            Duration::from_millis(500), // Long tick rate to ensure we test shutdown
        );

        // Spawn the handler
        let handle = tokio::spawn(handler.run());

        // Give it a moment to start
        tokio::time::sleep(Duration::from_millis(50)).await;

        // Send shutdown signal
        let _ = shutdown_tx.send(());

        // Handler should complete within a reasonable timeout
        let result = tokio::time::timeout(Duration::from_secs(2), handle).await;
        assert!(result.is_ok(), "Handler should complete within timeout");

        let inner_result = result.unwrap();
        assert!(inner_result.is_ok(), "Spawn should complete without panic");
        assert!(
            inner_result.unwrap().is_ok(),
            "Handler should return Ok on shutdown"
        );
    }

    #[tokio::test]
    async fn event_handler_stops_when_receiver_dropped() {
        let (event_tx, event_rx) = mpsc::channel(1);
        let (_shutdown_tx, shutdown_rx) = oneshot::channel::<()>();

        let handler = EventHandler::with_tick_rate(
            event_tx,
            shutdown_rx,
            Duration::from_millis(5), // Fast tick rate to quickly fill buffer
        );

        // Spawn the handler
        let handle = tokio::spawn(handler.run());

        // Give it a moment to start and send events
        tokio::time::sleep(Duration::from_millis(20)).await;

        // Drop the receiver - this should cause the handler to exit
        // when it tries to send the next event
        drop(event_rx);

        // Handler should complete since receiver is dropped
        let result = tokio::time::timeout(Duration::from_secs(2), handle).await;
        assert!(result.is_ok(), "Handler should complete within timeout");
        assert!(
            result.unwrap().unwrap().is_ok(),
            "Handler should return Ok when receiver dropped"
        );
    }

    #[tokio::test]
    async fn event_handler_generates_tick_events() {
        let (event_tx, mut event_rx) = mpsc::channel(100);
        let (shutdown_tx, shutdown_rx) = oneshot::channel();

        let handler = EventHandler::with_tick_rate(
            event_tx,
            shutdown_rx,
            Duration::from_millis(5), // Fast tick rate for testing
        );

        // Spawn the handler
        let handle = tokio::spawn(handler.run());

        // Collect tick events with a timeout
        let mut tick_count = 0;
        let deadline = tokio::time::Instant::now() + Duration::from_millis(200);

        while tokio::time::Instant::now() < deadline {
            match tokio::time::timeout(Duration::from_millis(50), event_rx.recv()).await {
                Ok(Some(TuiEvent::Tick)) => {
                    tick_count += 1;
                    if tick_count >= 3 {
                        break;
                    }
                }
                Ok(Some(_)) => {
                    // Ignore other events
                }
                Ok(None) => {
                    // Channel closed
                    break;
                }
                Err(_) => {
                    // Timeout on individual recv, continue
                }
            }
        }

        // We should have received at least 3 tick events
        assert!(
            tick_count >= 3,
            "Expected at least 3 tick events, got {}",
            tick_count
        );

        // Clean shutdown
        let _ = shutdown_tx.send(());
        let _ = tokio::time::timeout(Duration::from_secs(1), handle).await;
    }
}
