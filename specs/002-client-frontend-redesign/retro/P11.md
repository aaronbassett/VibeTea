# Phase 11 Retrospective: Polish & Cross-Cutting Concerns

## What Worked Well
<!-- Effective patterns, tools, approaches -->

### FR-009 Animation Performance Compliance (Verified 2026-02-04)

The dashboard architecture effectively maintains 60fps with the "max 10 concurrent animations" constraint through a layered approach:

1. **CSS-first for ambient effects**: AnimatedBackground uses pure CSS `@keyframes` for grid flicker and particle drift (15 particles max). CSS animations run on the GPU compositor thread, not blocking the main thread.

2. **Explicit throttling for event bursts**: `useAnimationThrottle` hook enforces max 10 entrance animations per second in EventStream via sliding 1-second window timestamp gating.

3. **State-driven glow effects**: Heatmap glow uses inline style updates (`boxShadow`, `filter`) rather than Framer Motion animation instances, keeping animation count low.

4. **Selective animation pausing**: `usePageVisibility` and `useIntersectionObserver` hooks automatically pause background animations when tab is hidden or element is off-screen.

## What Didn't Work
<!-- Problems, issues, limitations encountered -->

## Workarounds & Solutions
<!-- Bug fixes, non-obvious solutions, clever workarounds -->

### Animation Count Management

- **CSS animations vs Framer Motion**: CSS keyframe animations (particles, flicker, pulses) don't count toward concurrent JS animation limits since they run on compositor thread
- **AnimatePresence mode="popLayout"**: Used in SessionOverview to handle session card enter/exit without layout thrashing
- **animatedEventIdsRef tracking**: EventStream tracks which events have already animated via `Set<string>` ref to prevent re-animation on re-render

## Packages & Dependencies
<!-- Useful packages discovered, packages to avoid, version issues -->

## Patterns & Code
<!-- Reusable patterns, helpful code snippets, architectural insights -->

### Animation Throttling Pattern (useAnimationThrottle)

```typescript
// Sliding window throttle for entrance animations
const timestampsRef = useRef<number[]>([]);

const shouldAnimate = useCallback((): boolean => {
  const now = Date.now();
  // Remove timestamps older than 1 second
  timestampsRef.current = timestampsRef.current.filter(t => t > now - 1000);

  if (timestampsRef.current.length >= MAX_ANIMATIONS_PER_SECOND) {
    return false; // Throttled
  }

  timestampsRef.current.push(now);
  return true;
}, []);
```

### Worst-Case Animation Count Analysis

| Component | Type | Max Count | Notes |
|-----------|------|-----------|-------|
| AnimatedBackground | CSS | 15 | Particles, GPU-accelerated |
| SessionOverview | Framer | ~5 | Session cards, bounded by session count |
| Heatmap | Mixed | 1 | Tooltip only for Framer; glow is style updates |
| EventStream | Framer | 10 | Explicitly throttled |
| ConnectionStatus | Framer | 1 | Single indicator |
| Charts (Activity/Distribution) | Recharts | 2 | Built-in transitions |

Normal operation: 5-10 concurrent Framer Motion animations, well under the limit.

## For Next Time
<!-- Improvement suggestions, lessons learned, things to try differently -->

### Animation Performance Monitoring

Consider adding dev-only performance monitoring:
- Animation frame rate tracking via `requestAnimationFrame` timing
- Warning when concurrent animation count exceeds threshold
- React DevTools Profiler integration for render tracking
