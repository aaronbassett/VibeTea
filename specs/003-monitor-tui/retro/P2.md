# Phase 2 Retrospective: Foundational Infrastructure

## What Worked Well
- RAII pattern for terminal restoration with `restored` flag for idempotent cleanup
- Using `tokio::select!` with `biased` to prioritize shutdown signals
- Separating panic hook from RAII Drop to handle both normal and panic exits
- Using `spawn_blocking` for crossterm polling to avoid blocking async runtime
- Creating placeholder structs allowed incremental implementation

## What Didn't Work
- Nothing major - the foundational phase went smoothly

## Workarounds & Solutions
- Terminal polling in non-TTY environments (CI) gracefully returns `None` instead of erroring
- Used `oneshot::Receiver` for shutdown signal - simpler than `CancellationToken` for single-use

## Packages & Dependencies
- **ratatui** (0.29): Terminal UI framework for Rust - immediate mode API works well with async
- **crossterm** (0.28): Cross-platform terminal manipulation - `event::poll()` allows non-blocking
- **tokio::sync::oneshot**: Lightweight shutdown signaling for event handler

## Patterns & Code
- **RAII Terminal**: `Tui` struct with `restored: bool` flag prevents double cleanup in Drop
- **Panic Hook**: `install_panic_hook()` captures previous hook, restores terminal first, then chains
- **EventHandler**: Uses `tokio::select!` with tick interval, terminal polling via spawn_blocking, shutdown receiver
- **Theme/Symbols**: `from_env()` and `detect()` patterns for environment-based configuration
- **Sender Metrics**: Atomic counters tracked in Sender, exposed via `metrics()` snapshot

## For Next Time
- Consider using `tokio_util::sync::CancellationToken` if multiple shutdown listeners needed
- Test TUI code in actual terminals early, not just in CI
- The crossterm event polling pattern could be extracted to a reusable helper
