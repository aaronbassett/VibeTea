# Phase 9 Retrospective: User Story 7 - Key Management Options

## What Worked Well

- **Atomic backup with restore-on-failure**: The `backup_existing_keys()` function attempts to restore the private key backup if the public key backup fails, providing best-effort atomicity
- **Idempotent operations**: `backup_existing_keys()` returns `Ok(None)` when no keys exist rather than an error, making it safe to call unconditionally
- **Clear separation of concerns**: Key backup logic lives in `crypto.rs` while conditional UI rendering is in the widget, keeping the TUI layer focused on presentation
- **Comprehensive test coverage**: 8 dedicated backup tests covering success, failure, edge cases, and partial failure scenarios

## What Didn't Work

- **Timestamp format initially lacked clarity**: The YYYYMMDD_HHMMSS format needed documentation to explain why it's lexicographically sortable
- **Public key only scenario edge case**: Had to decide how to handle the case where only a public key exists without private key (decided to check only for private key existence)

## Workarounds & Solutions

- **Partial failure recovery**: If public key backup fails after private key was renamed, we restore the private key backup to maintain consistency
- **Conditional UI without radio buttons**: When only one option is available (no existing keys), display it as simple text instead of a single-item radio group

## Packages & Dependencies

- **chrono::Local**: Used for timestamp generation with `Local::now().format("%Y%m%d_%H%M%S")` - reliable and timezone-aware
- **No new dependencies required**: All functionality implemented using existing crates (chrono already in use)

## Patterns & Code

- **Timestamp-suffixed backup naming**: `key.priv.backup.20260204_143022` format (15-char timestamp, lexicographically sortable)
- **Conditional UI rendering**: Check `existing_keys_found` state to determine whether to show radio buttons or single option
- **Generate-with-backup compound operation**: `Crypto::generate_with_backup()` combines backup + generate + save atomically

## For Next Time

- Consider backup cleanup policy for old backup files
- Integration tests could verify backup behavior with real key paths
- `fs::rename()` is atomic on POSIX but verify Windows behavior for cross-platform
