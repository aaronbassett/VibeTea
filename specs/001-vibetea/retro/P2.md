# Phase 2 Retrospective: Foundational

## What Worked Well
- Parallel agent execution for independent modules (types, config, error) significantly sped up implementation
- Using thiserror 2.0 for error handling - clean derive macros
- Zustand v5 simplified API made store implementation straightforward
- TypeScript discriminated unions with type guards provide excellent type safety

## What Didn't Work
- thiserror 2.0 treats fields named `source` as error sources by default - required manual Error impl for ServerError
- vite-plugin-compression2 v2.x changed API from `algorithm` to `algorithms`

## Workarounds & Solutions
- For thiserror source field conflict: Use manual `Display` and `Error` trait implementations instead of derive when you need a `source` field that's not an error source
- For Tailwind v4: Content detection is automatic, no need to specify content paths

## Packages & Dependencies
- **gethostname** (1.0): Cross-platform hostname detection for Rust
- **directories** (6.0): Resolves ~ in paths, handles XDG on Linux
- **Zustand** (5.0): Simpler TypeScript API than v4, no curried form needed
- **Tailwind v4**: CSS-first config via @theme directive, @tailwindcss/vite plugin, no PostCSS needed

## Patterns & Code
- Rust EventPayload: Use `#[serde(untagged)]` with variants ordered from most to least specific fields for correct deserialization
- TypeScript EventPayload: Use discriminated union with `type` field for type-safe pattern matching
- Config pattern: Parse env vars in `from_env()` method, validate at end, return Result

## For Next Time
- Consider creating a shared types crate for monitor/server to avoid duplication
- Add integration tests that verify JSON serialization matches between Rust and TypeScript types
