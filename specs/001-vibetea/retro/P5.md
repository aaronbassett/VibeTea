# Phase 5 Retrospective: Monitor Privacy Pipeline (US3)

## What Worked Well
- **Privacy-by-design approach**: Defining sensitive tools as a constant array (`SENSITIVE_TOOLS`) made it easy to add/remove tools from stripping logic
- **Integration tests**: 17 comprehensive privacy compliance tests provided confidence that no sensitive data leaks
- **Builder pattern for config**: `PrivacyConfig::from_env()` cleanly separates environment parsing from pipeline logic
- **Path extraction utility**: `extract_basename()` function handles edge cases (empty paths, no extension, Windows paths)

## What Didn't Work
- N/A - The implementation was straightforward

## Workarounds & Solutions
- **Extension normalization**: The allowlist parser handles both `.rs` and `rs` formats by auto-prepending dots
- **Empty entry filtering**: Comma-separated parsing filters out empty entries from malformed input like `.rs,,.ts`
- **Whitespace trimming**: Extensions are trimmed to handle user input like ` .rs , .ts `

## Packages & Dependencies
- No new dependencies required - used existing `std::path::Path` for path manipulation
- `tracing::debug` for logging privacy decisions without exposing sensitive data

## Patterns & Code
- **Sensitive tool detection**: Hardcoded list prevents accidental transmission of command contents
- **Event payload pattern matching**: Rust's enum matching cleanly separates handling for Tool, Session, Summary events
- **Option propagation**: Using `Option<HashSet>` for allowlist means `None` = allow all (fail-open for usability)

## For Next Time
- Consider adding metrics/counters for stripped events to help users understand privacy filtering
